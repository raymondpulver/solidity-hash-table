{
 "bytecode": "0x605f6026600b82828239805160001a6073141515601857fe5b30600052607381538281f350fe73000000000000000000000000000000000000000030146080604052600436106023575b60006000fdfea264697066735822122096094b712ce17ddbda9245ab6d51d557149b2df40cb83edaccfd246c8684dac964736f6c63430006000033",
 "src": " pragma solidity ^0.6.0;\n\nlibrary HashTableLib {\n  struct BTreeNode {\n    bytes4 leafNode;\n    bytes4[] ptrs;\n  }\n  struct Bucket {\n    bytes32 key;\n    bytes32 ptr;\n  }\n  struct LeafNode {\n    bytes32 bucket;\n    bytes32 next;\n  }\n  struct HashTable {\n    bytes32 ptr;\n  }\n  function getBucketFromPtr(bytes32 ptr) internal pure returns (Bucket memory retval) {\n    assembly {\n      retval := ptr\n    }\n  }\n  function lookupValueFromLeafNode(bytes32 leafNodePtr, bytes32 key) internal pure returns (bytes32) {\n    LeafNode memory leafNode;\n    assembly {\n      leafNode := leafNodePtr\n    }\n    while (true) {\n      assembly {\n        leafNodePtr := leafNode\n      }\n      Bucket memory bucket = getBucketFromPtr(leafNode.bucket);\n      if (bucket.key == key) return bucket.ptr;\n      leafNode = getLeafNodeFromPtr(toBytes4(leafNode.next));\n    }\n  }\n  function insertKeyValueFromLeafNode(bytes32 leafNodePtr, bytes32 key, bytes32 ptr) internal pure {\n    LeafNode memory leafNode;\n    assembly {\n      leafNode := leafNodePtr\n    }\n    bytes32 bucket = leafNode.bucket;\n    Bucket memory newBucket;\n    while (true) {\n      if (bucket == 0) {\n        newBucket = Bucket({\n          key: key,\n          ptr: ptr\n        });\n        break;\n      } else {\n        assembly {\n          leafNodePtr := leafNode\n        }\n        if (leafNodePtr == 0) {\n          leafNode = allocLeafNode();\n        } else {\n          leafNode = getLeafNodeFromPtr(toBytes4(leafNode.next));\n          bucket = leafNode.bucket;\n        }\n      }\n    }\n  }\n  function getOrAllocLeafNodeFromPtr(bytes4 ptr) internal pure returns (bytes4, LeafNode memory retval) {\n    bytes4 resultPtr;\n    if (ptr == 0) {\n      retval = allocLeafNode();\n      assembly {\n        resultPtr := retval\n      }\n      return (resultPtr, retval);\n    }\n    return (ptr, getLeafNodeFromPtr(ptr));\n  }\n  function allocLeafNode() internal pure returns (LeafNode memory) {\n    return LeafNode({\n      bucket: bytes32(0x0),\n      next: bytes32(0x0)\n    });\n  }\n  function toPtr(LeafNode memory leafNode) internal pure returns (bytes4 ptr) {\n    bytes32 word;\n    assembly {\n      word := leafNode\n    }\n    ptr = bytes4(uint32(uint256(word)));\n  }\n  function getLeafNodeFromPtr(bytes4 ptr) internal pure returns (LeafNode memory retval) {\n    assembly {\n      retval := ptr\n    }\n  }\n  function toBytes4(bytes32 ptr) internal pure returns (bytes4 result) {\n    result = bytes4(uint32(uint256(ptr)));\n  }\n  function fromBTreeNode(BTreeNode memory btn) internal pure returns (HashTable memory retval) {\n    bytes32 ptr;\n    assembly {\n      ptr := btn\n    }\n    retval.ptr = ptr;\n  }\n  function getBTreeNode(HashTable memory ht) internal pure returns (BTreeNode memory retval) {\n    bytes32 ptr = ht.ptr;\n    assembly {\n      retval := ptr\n    }\n  }\n  function allocBTreeNode() internal pure returns (BTreeNode memory) {\n    return BTreeNode({\n      leafNode: bytes4(0x0),\n      ptrs: new bytes4[](0x0)\n    });\n  }\n  function getBTreeNodeFromPtr(bytes4 ptr) internal pure returns (BTreeNode memory retval) {\n    assembly {\n      retval := ptr\n    }\n  }\n  function getOrAllocBTreeNodeFromPtr(bytes4 ptr) internal pure returns (bytes4, BTreeNode memory retval) {\n    bytes4 resultPtr;\n    if (ptr == 0) {\n      retval = allocBTreeNode();\n      assembly {\n        resultPtr := retval\n      }\n      return (resultPtr, retval);\n    }\n    return (ptr, getBTreeNodeFromPtr(ptr));\n  }\n  function possiblyExpandBTreePtrs(BTreeNode memory btn) internal pure {\n    if (btn.ptrs.length == 0) btn.ptrs = new bytes4[](0x100);\n  }\n  function createHashTable() internal pure returns (HashTable memory) {\n    BTreeNode memory encapsulated = allocBTreeNode();\n    HashTable memory retval = HashTable({\n      ptr: 0\n    }); \n    bytes32 ptr;\n    assembly {\n      ptr := encapsulated\n    }\n    retval.ptr = ptr;\n  }\n  function lookup(HashTable memory ht, bytes32 key) internal pure returns (bool exists, bytes32 val) {\n    BTreeNode memory btn = getBTreeNode(ht);\n    bytes32 hash = keccak256(abi.encodePacked(key)) & bytes32((uint256(0x1) << 0x20) - 1);\n    for (uint256 i = 31; i > 27; i--) {\n      if ((~bytes32((uint256(0x1) << (i + 1)*8) - 1) & hash) == 0) {\n        if (btn.leafNode != 0) return (true, lookupValueFromLeafNode(bytes32(uint256(uint32(btn.leafNode))), key));\n        return (false, bytes32(uint256(0x0)));\n      }\n      uint256 b = uint256(uint8(hash[i]));\n      if (btn.ptrs.length == 0) return (false, bytes32(uint256(0x0)));\n      bytes4 ptr = bytes4(uint32(btn.ptrs[b]));\n      if (ptr == 0) return (false, bytes32(uint256(0x0)));\n      btn = getBTreeNodeFromPtr(ptr);\n    }\n  }\n  function insert(HashTable memory ht, bytes32 key, bytes32 val) internal pure {\n    BTreeNode memory btn = getBTreeNode(ht);\n    bytes32 hash = keccak256(abi.encodePacked(key)) & bytes32((uint256(0x1) << uint256(0x20)) - 1);\n    for (uint256 i = 31; i > 27; i--) {\n      if ((~bytes32((0x1 << (i + 1)*8) - 1) & hash) == 0) {\n        \n        btn.leafNode = toPtr(allocLeafNode());\n        insertKeyValueFromLeafNode(bytes32(uint256(uint32(btn.leafNode))), key, val);\n      }\n      possiblyExpandBTreePtrs(btn);\n      uint256 b = uint256(uint8(hash[i]));\n      bytes4 ptr = btn.ptrs[b];\n      (ptr, btn) = getOrAllocBTreeNodeFromPtr(ptr);\n    }\n  }\n}\n"
}