{
 "bytecode": "0x605f6026600b82828239805160001a6073141515601857fe5b30600052607381538281f350fe73000000000000000000000000000000000000000030146080604052600436106023575b60006000fdfea264697066735822122025303a82b5c0cf047efd28625bf51ffb40d310eb0fae198fb94ac9fb8621ab4064736f6c63430006000033",
 "src": " pragma solidity ^0.6.0;\n\nimport \"./BTreeNodeLib.sol\";\nimport \"./BTreeExtensionLib.sol\";\nimport \"./BucketLib.sol\";\n\nlibrary HashTableLib {\n  using BTreeNodeLib for *;\n  using BTreeExtensionLib for *;\n  using BucketLib for *;\n  bytes32 constant NIBBLE_MASK = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n  struct HashTable {\n    uint32 ptr;\n  }\n  function create() internal pure returns (HashTable memory) {\n    BTreeNodeLib.BTreeNode memory node = BTreeNodeLib.create();\n    return HashTable({\n      ptr: node.toPtr()\n    });\n  }\n  function lookup(HashTable memory ht, bytes32 key) internal pure returns (bool exists, bytes32 val) {\n    BTreeNodeLib.BTreeNode memory btn = ht.ptr.asNode();\n    bytes32 hash = keccak256(abi.encodePacked(key)) & bytes32((uint256(0x1) << 0x20) - 1) & NIBBLE_MASK;\n    for (uint256 i = 31; i > 27; i--) {\n      if (btn.leafNode == 0) {\n        if (btn.ptrs.length == 0) return (false, bytes32(uint256(0x0)));\n        uint32 ptr = btn.ptrs[hash[i]];\n        if (ptr == 0) return (false, bytes32(uint256(0x0)));\n        btn = ptr.asNode();\n      } else {\n        BTreeExtensionLib.BTreeExtension memory extension = btn.leafNode.asExtension();\n        if (extension.getInputHash(i) == hash) return (true, extension.ptr.lookupValue(key));\n        return (false, extension.ptr.lookupValue(key));\n      }\n    }\n  }\n  function insert(HashTable memory ht, bytes32 key, bytes32 val) internal pure {\n    BTreeNodeLib.BTreeNode memory btn = btn.ptr.asNode();\n    bytes32 hash = keccak256(abi.encodePacked(key)) & bytes32((uint256(0x1) << uint256(0x20)) - 1) & NIBBLE_MASK;\n    for (uint256 i = 31; i > 27; i--) {\n      if (btn.leafNode != 0) {\n        BTreeExtensionLib.BTreeExtension memory extension = btn.leafNode.asExtension();\n        btn.leafNode = 0;\n        btn.expand();\n        BTreeNodeLib.BTreeNode memory node = BTreeNodeLib.create();\n        btn.ptrs[extension.current] = node.toPtr();\n        BTreeExtensionLib.BTreeExtension memory newExtension = BTreeExtensionLib.create(hash, i - 1, extension.ptr);\n        node.leafNode = newExtension.toPtr();\n        return (true, extension.ptr.insertKeyValue(key, val));\n      } else {\n        if (btn.ptrs.length == 0) {\n          BucketLib.Bucket memory bucket = BucketLib.create(key, val, 0);\n          BTreeExtensionLib.BTreeExtension memory extension = BTreeExtensionLib.create(hash, i, bucket.toPtr());\n          btn.leafNode = extension.toPtr();\n        } else {\n          uint32 ptr = btn.ptrs[hash[i]];\n          if (ptr == 0) {\n            BucketLib.Bucket memory bucket = BucketLib.create(key, val, 0);\n            BTreeExtensionLib.BTreeExtension memory extension = BTreeExtensionLib.create(hash, i, bucket.toPtr())\n            BTreeNodeLib.BTreeNode memory node = BTreeNodeLib.create();\n            node.leafNode = extension.toPtr();\n            btn.ptrs[hash[i]] = node.toPtr();\n          } else {\n            btn = ptr.asNode();\n          }\n        }\n      }\n    }\n  }\n}\n"
}