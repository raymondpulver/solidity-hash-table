{
 "bytecode": "0x605f6026600b82828239805160001a6073141515601857fe5b30600052607381538281f350fe73000000000000000000000000000000000000000030146080604052600436106023575b60006000fdfea26469706673582212209d90d2168b3e8f871d9d0b490bf055227354bdb29ba9a281a6d93293b74749bf64736f6c63430006000033",
 "src": " pragma solidity ^0.6.0;\n\nimport \"./BTreeNodeLib.sol\";\nimport \"./BTreeExtensionLib.sol\";\nimport \"./BucketLib.sol\";\n\nlibrary HashTableLib {\n  using BTreeNodeLib for *;\n  using BTreeExtensionLib for *;\n  using BucketLib for *;\n  uint256 constant NIBBLE_MASK = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n  struct HashTable {\n    BTreeNodeLib.BTreeNode ptr;\n  }\n  function initialize() internal pure returns (HashTable memory) {\n    BTreeNodeLib.BTreeNode memory node = BTreeNodeLib.initialize();\n    return HashTable({\n      ptr: node\n    });\n  }\n  function lookup(HashTable memory ht, bytes32 key) internal pure returns (bool exists, bytes32 val) {\n    BTreeNodeLib.BTreeNode memory btn = ht.ptr;\n    uint256 hash = uint256(keccak256(abi.encodePacked(key))) & ((uint256(0x1) << 0x20) - 1) & NIBBLE_MASK;\n    for (uint256 i = 31; i > 27; i--) {\n      if (btn.leafNode == 0) {\n        if (btn.ptrs.length == 0) return (false, bytes32(uint256(0x0)));\n        uint256 ptr = btn.get(uint256(uint8(bytes32(hash)[i])));\n        if (ptr == 0) return (false, bytes32(uint256(0x0)));\n        btn = ptr.asNode();\n      } else {\n        BTreeExtensionLib.BTreeExtension memory extension = btn.leafNode.asExtension();\n        if (extension.hash == hash) return (true, extension.ptr.lookupValue(key));\n        return (false, extension.ptr.lookupValue(key));\n      }\n    }\n  }\n  event Woop(bytes32 indexed data);\n  function insert(HashTable memory ht, bytes32 key, bytes32 val) internal returns (BucketLib.Bucket memory) {\n    BTreeNodeLib.BTreeNode memory btn = ht.ptr;\n    uint256 hash = uint256(keccak256(abi.encodePacked(key))) & ((uint256(0x1) << uint256(0x20)) - 1) & NIBBLE_MASK;\n    bytes memory placeholder;\n    for (uint256 i = 31; i > 0; i--) {\n      emit Woop(bytes32(hash));\n      uint256 current = uint256(uint8(bytes32(hash)[i]));\n      emit Woop(bytes32(current));\n      if (btn.leafNode != 0) {\n        BTreeExtensionLib.BTreeExtension memory extension = btn.leafNode.asExtension();\n        if (extension.hash == hash) return extension.ptr.insertKeyValue(key, val);\n        btn.leafNode = 0;\n        btn.expand();\n        BTreeNodeLib.BTreeNode memory node = BTreeNodeLib.initialize();\n        BTreeExtensionLib.BTreeExtension memory lastExtended = BTreeExtensionLib.initialize(extension.hash, i - 1, extension.ptr);\n        node.leafNode = lastExtended.toPtr();\n        btn.set(extension.current, node.toPtr());\n        if (extension.current != current) {\n          BTreeNodeLib.BTreeNode memory newNode = BTreeNodeLib.initialize();\n          btn.set(current, newNode.toPtr());\n          btn = newNode;\n        } else btn = node;\n        placeholder = new bytes(0);\n      } else {\n        if (btn.ptrs.length == 0) {\n          BTreeExtensionLib.BTreeExtension memory extension = BTreeExtensionLib.initialize(hash, i, 0);\n          BucketLib.Bucket memory bucket = BucketLib.initialize(key, val, 0);\n          extension.ptr = bucket.toPtr();\n          btn.leafNode = extension.toPtr();\n          return bucket;\n        } else {\n          uint256 ptr = btn.get(uint256(uint8(bytes32(hash)[i])));\n          if (ptr == 0) {\n            BucketLib.Bucket memory bucket = BucketLib.initialize(key, val, 0);\n            BTreeExtensionLib.BTreeExtension memory extension = BTreeExtensionLib.initialize(hash, i, bucket.toPtr());\n            BTreeNodeLib.BTreeNode memory node = BTreeNodeLib.initialize();\n            node.leafNode = extension.toPtr();\n            btn.set(uint256(uint8(bytes32(hash)[i])), node.toPtr());\n          } else {\n            btn = ptr.asNode();\n          }\n        }\n      }\n    }\n    return BucketLib.Bucket({\n      key: bytes32(uint256(0x0)),\n      val: bytes32(uint256(0x0)),\n      next: uint256(0x0)\n    });\n  }\n}\n"
}