{
 "bytecode": "0x605f6026600b82828239805160001a6073141515601857fe5b30600052607381538281f350fe73000000000000000000000000000000000000000030146080604052600436106023575b60006000fdfea26469706673582212200b9e06066fc5c5733f5e5ded50353092bc02ada9ce7bfc84fedd05da7f9d7dd164736f6c63430006000033",
 "src": " pragma solidity ^0.6.0;\n\nlibrary HashTableLib {\n  struct BTreeNode {\n    uint32 leafNode;\n    uint32[] ptrs;\n  }\n  struct Bucket {\n    bytes32 key;\n    bytes32 ptr;\n  }\n  struct LeafNode {\n    bytes32 bucket;\n    bytes32 next;\n  }\n  struct HashTable {\n    uint32 ptr;\n  }\n  function toUint32(bytes32 ptr) internal pure returns (uint32) {\n    return uint32(uint256(ptr));\n  }\n  function getBucketFromPtr(bytes32 ptr) internal pure returns (Bucket memory retval) {\n    assembly {\n      retval := ptr\n    }\n  }\n  function lookupValueFromLeafNode(uint32 leafNodePtr, bytes32 key) internal pure returns (bytes32) {\n    LeafNode memory leafNode;\n    assembly {\n      leafNode := leafNodePtr\n    }\n    while (true) {\n      assembly {\n        leafNodePtr := leafNode\n      }\n      if (leafNode.bucket == 0) return bytes32(0x0);\n      Bucket memory bucket = getBucketFromPtr(leafNode.bucket);\n      if (bucket.key == key) return bucket.ptr;\n      leafNode = getLeafNodeFromPtr(toUint32(leafNode.next));\n    }\n  }\n  function insertKeyValueFromLeafNode(uint32 leafNodePtr, bytes32 key, bytes32 ptr) internal pure {\n    LeafNode memory leafNode;\n    assembly {\n      leafNode := leafNodePtr\n    }\n    bytes32 bucket = leafNode.bucket;\n    Bucket memory newBucket;\n    while (true) {\n      if (bucket == 0) {\n        newBucket = Bucket({\n          key: key,\n          ptr: ptr\n        });\n        assembly {\n          bucket := newBucket\n        }\n        leafNode.bucket = bucket;\n        break;\n      } else {\n        assembly {\n          leafNodePtr := leafNode\n        }\n        if (leafNodePtr == 0) {\n          leafNode = allocLeafNode();\n        } else {\n          leafNode = getLeafNodeFromPtr(toUint32(leafNode.next));\n          bucket = leafNode.bucket;\n        }\n      }\n    }\n  }\n  function getOrAllocLeafNodeFromPtr(uint32 ptr) internal pure returns (uint32, LeafNode memory retval) {\n    uint32 resultPtr;\n    if (ptr == 0) {\n      retval = allocLeafNode();\n      assembly {\n        resultPtr := retval\n      }\n      return (resultPtr, retval);\n    }\n    return (ptr, getLeafNodeFromPtr(ptr));\n  }\n  function allocLeafNode() internal pure returns (LeafNode memory) {\n    return LeafNode({\n      bucket: bytes32(0x0),\n      next: bytes32(0x0)\n    });\n  }\n  function toPtr(LeafNode memory leafNode) internal pure returns (uint32 ptr) {\n    assembly {\n      ptr := leafNode\n    }\n  }\n  function getLeafNodeFromPtr(uint32 ptr) internal pure returns (LeafNode memory retval) {\n    assembly {\n      retval := ptr\n    }\n  }\n  function fromBTreeNode(BTreeNode memory btn) internal pure returns (HashTable memory retval) {\n    uint32 ptr;\n    assembly {\n      ptr := btn\n    }\n    retval.ptr = ptr;\n  }\n  function getBTreeNode(HashTable memory ht) internal pure returns (BTreeNode memory retval) {\n    uint32 ptr = ht.ptr;\n    assembly {\n      retval := ptr\n    }\n  }\n  function allocBTreeNode() internal pure returns (BTreeNode memory) {\n    return BTreeNode({\n      leafNode: uint32(0x0),\n      ptrs: new uint32[](0x0)\n    });\n  }\n  function getBTreeNodeFromPtr(uint32 ptr) internal pure returns (BTreeNode memory retval) {\n    assembly {\n      retval := ptr\n    }\n  }\n  function getOrAllocBTreeNodeFromPtr(uint32 ptr) internal pure returns (uint32, BTreeNode memory retval) {\n    uint32 resultPtr;\n    if (ptr == 0) {\n      retval = allocBTreeNode();\n      assembly {\n        resultPtr := retval\n      }\n      return (resultPtr, retval);\n    }\n    return (ptr, getBTreeNodeFromPtr(ptr));\n  }\n  function possiblyExpandBTreePtrs(BTreeNode memory btn) internal pure {\n    if (btn.ptrs.length == 0) btn.ptrs = new uint32[](0x10);\n  }\n  function createHashTable() internal pure returns (HashTable memory) {\n    BTreeNode memory encapsulated = allocBTreeNode();\n    HashTable memory retval = HashTable({\n      ptr: 0\n    }); \n    bytes32 ptr;\n    assembly {\n      ptr := encapsulated\n    }\n    retval.ptr = uint32(uint256(ptr));\n  }\n  bytes32 constant NIBBLE_MASK = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n  function lookup(HashTable memory ht, bytes32 key) internal pure returns (bool exists, bytes32 val) {\n    BTreeNode memory btn = getBTreeNode(ht);\n    bytes32 hash = keccak256(abi.encodePacked(key)) & bytes32((uint256(0x1) << 0x20) - 1) & NIBBLE_MASK;\n    for (uint256 i = 31; i > 27; i--) {\n      if ((~bytes32((uint256(0x1) << (i + 1)*8) - 1) & hash) == 0) {\n        if (btn.leafNode != 0) return (true, lookupValueFromLeafNode(btn.leafNode, key));\n        return (false, bytes32(uint256(0x0)));\n      }\n      uint256 b = uint256(uint8(hash[i]));\n      if (btn.ptrs.length == 0) return (false, bytes32(uint256(0x0)));\n      uint32 ptr = uint32(btn.ptrs[b]);\n      if (ptr == 0) return (false, bytes32(uint256(0x0)));\n      btn = getBTreeNodeFromPtr(ptr);\n    }\n  }\n  function insert(HashTable memory ht, bytes32 key, bytes32 val) internal pure {\n    BTreeNode memory btn = getBTreeNode(ht);\n    bytes32 hash = keccak256(abi.encodePacked(key)) & bytes32((uint256(0x1) << uint256(0x20)) - 1) & NIBBLE_MASK;\n    for (uint256 i = 31; i > 27; i--) {\n      if ((~bytes32((0x1 << (i + 1)*8) - 1) & hash) == 0) {\n        \n        btn.leafNode = toPtr(allocLeafNode());\n        insertKeyValueFromLeafNode(btn.leafNode, key, val);\n        return;\n      }\n      possiblyExpandBTreePtrs(btn);\n      uint256 b = uint256(uint8(hash[i]));\n      uint32 ptr = btn.ptrs[b];\n      (ptr, btn) = getOrAllocBTreeNodeFromPtr(ptr);\n    }\n  }\n}\n"
}